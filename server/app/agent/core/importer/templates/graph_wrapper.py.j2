# AUTO-GENERATED by Agent Import System — Phase 1 thin-wrapper scaffold
# Plugin ID      : {{ plugin_id }}
# External graph : {{ external_module }}.{{ graph_export }}
# Strategy       : thin_wrapper
#
# The external graph runs untouched inside a single LangGraph node.
# Its state is translated to/from the CommonState envelope here.
# Re-run import to regenerate, or edit freely for custom behaviour.

from __future__ import annotations

import json
import logging
import operator
import os
import sys
from typing import Annotated, Any, Dict, List, Optional

from langgraph.graph import END, START, StateGraph
from typing_extensions import TypedDict

# ── Ensure the external source (copied into src/) is importable ───────────────
_SRC_DIR = os.path.join(os.path.dirname(__file__), "src")
if _SRC_DIR not in sys.path:
    sys.path.insert(0, _SRC_DIR)
# Repos using src-layout (code lives in src/<pkg>/) need the inner src/ on sys.path too
_SRC_SRC = os.path.join(_SRC_DIR, "src")
if os.path.isdir(_SRC_SRC) and _SRC_SRC not in sys.path:
    sys.path.insert(0, _SRC_SRC)

# External graph is lazy-loaded on first real invocation so that:
#   a) importing this module does not trigger the agent's own deps / API keys, and
#   b) the smoke test (empty-transcript → handle_welcome path) succeeds without
#      credentials in the environment.
_external_graph = None

logger = logging.getLogger(__name__)

# ── A2UI screen definitions (Phase 1 defaults; replaced by LLM in Phase 2) ────
_SCREENS = {{ screens | tojson(indent=4) }}


# ── CommonState TypedDict (must match contracts.CommonState) ──────────────────

class WrappedState(TypedDict, total=False):
    mode: str
    device: str
    transcript: str
    messages: Annotated[List[Dict[str, Any]], operator.add]
    ui: Dict[str, Any]
    errors: Optional[Dict[str, Any]]
    pendingAction: Optional[Dict[str, Any]]
    outbox: Annotated[List[Dict[str, Any]], operator.add]
    meta: Dict[str, Any]
    domain: Dict[str, Any]
    state_version: int


# ── A2UI helpers ───────────────────────────────────────────────────────────────

def _a2ui_patch(components: list, title: str) -> Dict[str, Any]:
    return {
        "type": "server.a2ui.patch",
        "payload": {
            "updateComponents": {"components": components},
            "title": title,
        },
    }


def _render_screen(screen_key: str, response: str = "") -> list:
    """
    Return outbox events for a given screen key.
    '{response}' placeholders in voice_text and DataCard detail are substituted.
    """
    screen = _SCREENS.get(screen_key, _SCREENS.get("result", {}))
    components = screen.get("components", [])
    voice_text = screen.get("voice_text", response).replace("{response}", response)
    title = screen.get("title", "Response")

    # Deep-substitute {response} in component data fields.
    # json.dumps()[1:-1] gives a correctly-escaped JSON string value (no outer quotes),
    # which is safe to splice into an already-serialised JSON document.
    components_rendered = json.loads(
        json.dumps(components).replace("{response}", json.dumps(response)[1:-1])
    )

    events = [_a2ui_patch(components_rendered, title)]
    if voice_text:
        events.append({"type": "server.voice.say", "payload": {"text": voice_text[:300]}})
        events.append({
            "type": "server.transcript.final",
            "payload": {"text": voice_text, "role": "assistant"},
        })
    return events


# ── Graph nodes ────────────────────────────────────────────────────────────────

def handle_welcome(state: WrappedState) -> dict:
    """Emit the welcome screen when no transcript is present."""
    return {"outbox": _render_screen("welcome")}


def run_external_graph(state: WrappedState) -> dict:
    """
    Translate CommonState → external state, invoke the external graph,
    translate the result back to outbox events.
    """
    global _external_graph
    transcript = (state.get("transcript") or "").strip()

    # ── Input translation ────────────────────────────────────────────────────
    {% if input_field == "messages" %}
    from langchain_core.messages import HumanMessage
    ext_input = {"{{ input_field }}": [HumanMessage(transcript)]}
    {% else %}
    ext_input = {"{{ input_field }}": transcript}
    {% endif %}

    # ── Lazy load + invoke (both inside try so import errors surface cleanly) ─
    try:
        if _external_graph is None:
            from {{ external_module }} import {{ graph_export }} as _loaded  # noqa: E402
            _external_graph = _loaded
        ext_result = _external_graph.invoke(ext_input)
    except Exception as exc:
        logger.error("[{{ plugin_id }}] External graph error: %s", exc)
        return {"outbox": _render_screen("error")}

    # ── Output translation ───────────────────────────────────────────────────
    try:
        {% if "[-1]" in output_accessor %}
        _msgs = ext_result.get("{{ output_accessor.split('[')[0] }}", [])
        response = _msgs[-1].content if _msgs else ""
        {% else %}
        response = str(ext_result.get("{{ output_accessor }}", ""))
        {% endif %}
    except Exception:
        response = str(ext_result)

    return {"outbox": _render_screen("result", response=response)}


def handle_default(state: WrappedState) -> dict:
    """Catch-all fallback."""
    return {"outbox": _render_screen("error")}


def clear_pending_action(state: WrappedState) -> dict:
    return {"pendingAction": None, "transcript": ""}


# ── Router ─────────────────────────────────────────────────────────────────────

def start_router(state: WrappedState) -> str:
    transcript = (state.get("transcript") or "").strip()
    if not transcript:
        return "handle_welcome"
    return "run_external_graph"


# ── Graph assembly ─────────────────────────────────────────────────────────────

builder = StateGraph(WrappedState)

builder.add_node("handle_welcome",       handle_welcome)
builder.add_node("run_external_graph",   run_external_graph)
builder.add_node("handle_default",       handle_default)
builder.add_node("clear_pending_action", clear_pending_action)

# START → router decides which handler to call
builder.add_conditional_edges(
    START,
    start_router,
    {
        "handle_welcome":     "handle_welcome",
        "run_external_graph": "run_external_graph",
    },
)

builder.add_edge("handle_welcome",      "clear_pending_action")
builder.add_edge("run_external_graph",  "clear_pending_action")
builder.add_edge("handle_default",      "clear_pending_action")
builder.add_edge("clear_pending_action", END)

app_graph = builder.compile()
